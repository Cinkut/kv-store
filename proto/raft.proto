syntax = "proto3";

package kv.raft;

// --- Log Entry ---

enum CommandType {
    CMD_NOOP   = 0;      // Leader's first entry each term (no-op)
    CMD_SET    = 1;
    CMD_DEL    = 2;
    CMD_CONFIG = 3;      // Cluster configuration change (joint consensus)
}

message Command {
    CommandType type = 1;
    string key       = 2;
    string value     = 3;   // empty for DEL and NOOP
}

// --- Cluster Configuration (for dynamic membership) ---

// Describes a single node in the cluster.
message NodeInfo {
    uint32 id          = 1;  // unique node ID (> 0)
    string host        = 2;  // bind address / hostname
    uint32 raft_port   = 3;  // port for Raft RPC
    uint32 client_port = 4;  // port for client connections
}

// A cluster configuration: the set of nodes that form the Raft group.
// During joint consensus, both old_nodes and new_nodes are populated.
// In a stable (non-transitional) configuration, only new_nodes is used
// and old_nodes is empty.
message ClusterConfig {
    repeated NodeInfo old_nodes = 1;  // C_old members (empty when not in joint phase)
    repeated NodeInfo new_nodes = 2;  // C_new members (the target configuration)
}

message LogEntry {
    uint64        term    = 1;
    uint64        index   = 2;
    Command       command = 3;
    ClusterConfig config  = 4;  // populated when command.type == CMD_CONFIG
}

// --- RequestVote RPC ---

message RequestVoteRequest {
    uint64 term           = 1;  // candidate's term
    uint32 candidate_id   = 2;  // candidate requesting vote
    uint64 last_log_index = 3;  // index of candidate's last log entry
    uint64 last_log_term  = 4;  // term of candidate's last log entry
}

message RequestVoteResponse {
    uint64 term         = 1;    // currentTerm, for candidate to update itself
    bool   vote_granted = 2;    // true = candidate received vote
}

// --- AppendEntries RPC ---

message AppendEntriesRequest {
    uint64 term           = 1;  // leader's term
    uint32 leader_id      = 2;  // so follower can redirect clients
    uint64 prev_log_index = 3;  // index of log entry immediately preceding new ones
    uint64 prev_log_term  = 4;  // term of prevLogIndex entry
    repeated LogEntry entries = 5;  // log entries to store (empty for heartbeat)
    uint64 leader_commit  = 6;  // leader's commitIndex
}

message AppendEntriesResponse {
    uint64 term        = 1;     // currentTerm, for leader to update itself
    bool   success     = 2;     // true if follower contained entry matching prevLogIndex/prevLogTerm
    uint64 match_index = 3;     // highest log index known to be replicated on this follower
}

// --- InstallSnapshot RPC (Etap 4) ---

message InstallSnapshotRequest {
    uint64 term                = 1;
    uint32 leader_id           = 2;
    uint64 last_included_index = 3;  // snapshot replaces all entries up through this index
    uint64 last_included_term  = 4;  // term of last_included_index
    bytes  data                = 5;  // raw snapshot bytes (entire KV state)
    ClusterConfig config       = 6;  // cluster configuration at snapshot point
}

message InstallSnapshotResponse {
    uint64 term = 1;                 // currentTerm, for leader to update itself
}

// --- Wrapper for multiplexing on a single TCP connection ---

message RaftMessage {
    oneof payload {
        RequestVoteRequest       request_vote_req    = 1;
        RequestVoteResponse      request_vote_resp   = 2;
        AppendEntriesRequest     append_entries_req   = 3;
        AppendEntriesResponse    append_entries_resp  = 4;
        InstallSnapshotRequest   install_snapshot_req = 5;
        InstallSnapshotResponse  install_snapshot_resp = 6;
    }
}
