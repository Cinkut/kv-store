syntax = "proto3";

package kv.raft;

// --- Log Entry ---

enum CommandType {
    CMD_NOOP = 0;      // Leader's first entry each term (no-op)
    CMD_SET  = 1;
    CMD_DEL  = 2;
}

message Command {
    CommandType type = 1;
    string key       = 2;
    string value     = 3;   // empty for DEL and NOOP
}

message LogEntry {
    uint64  term    = 1;
    uint64  index   = 2;
    Command command = 3;
}

// --- RequestVote RPC ---

message RequestVoteRequest {
    uint64 term           = 1;  // candidate's term
    uint32 candidate_id   = 2;  // candidate requesting vote
    uint64 last_log_index = 3;  // index of candidate's last log entry
    uint64 last_log_term  = 4;  // term of candidate's last log entry
}

message RequestVoteResponse {
    uint64 term         = 1;    // currentTerm, for candidate to update itself
    bool   vote_granted = 2;    // true = candidate received vote
}

// --- AppendEntries RPC ---

message AppendEntriesRequest {
    uint64 term           = 1;  // leader's term
    uint32 leader_id      = 2;  // so follower can redirect clients
    uint64 prev_log_index = 3;  // index of log entry immediately preceding new ones
    uint64 prev_log_term  = 4;  // term of prevLogIndex entry
    repeated LogEntry entries = 5;  // log entries to store (empty for heartbeat)
    uint64 leader_commit  = 6;  // leader's commitIndex
}

message AppendEntriesResponse {
    uint64 term        = 1;     // currentTerm, for leader to update itself
    bool   success     = 2;     // true if follower contained entry matching prevLogIndex/prevLogTerm
    uint64 match_index = 3;     // highest log index known to be replicated on this follower
}

// --- InstallSnapshot RPC (Etap 4) ---

message InstallSnapshotRequest {
    uint64 term                = 1;
    uint32 leader_id           = 2;
    uint64 last_included_index = 3;  // snapshot replaces all entries up through this index
    uint64 last_included_term  = 4;  // term of last_included_index
    bytes  data                = 5;  // raw snapshot bytes (entire KV state)
}

message InstallSnapshotResponse {
    uint64 term = 1;                 // currentTerm, for leader to update itself
}

// --- Wrapper for multiplexing on a single TCP connection ---

message RaftMessage {
    oneof payload {
        RequestVoteRequest       request_vote_req    = 1;
        RequestVoteResponse      request_vote_resp   = 2;
        AppendEntriesRequest     append_entries_req   = 3;
        AppendEntriesResponse    append_entries_resp  = 4;
        InstallSnapshotRequest   install_snapshot_req = 5;
        InstallSnapshotResponse  install_snapshot_resp = 6;
    }
}
